/-
Copyright (c) 2017 Johannes Hölzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes Hölzl, Yury Kudryashov, Kim Morrison
-/
import Mathlib.Algebra.GroupWithZero.Action.TransferInstance
import Mathlib.Algebra.Module.Defs
import Mathlib.Data.Finsupp.Basic
import Mathlib.Data.Finsupp.SMulWithZero

/-!
# Monoid algebras

When the domain of a `Finsupp` has a multiplicative or additive structure, we can define
a convolution product. To mathematicians this structure is known as the "monoid algebra",
i.e. the finite formal linear combinations over a given semiring of elements of the monoid.
The "group ring" ℤ[G] or the "group algebra" k[G] are typical uses.

In fact the construction of the "monoid algebra" makes sense when `G` is not even a monoid, but
merely a magma, i.e., when `G` carries a multiplication which is not required to satisfy any
conditions at all. In this case the construction yields a not-necessarily-unital,
not-necessarily-associative algebra but it is still adjoint to the forgetful functor from such
algebras to magmas, and we prove this as `MonoidAlgebra.liftMagma`.

In this file we define `R[M] := G →₀ k`, and `AddMonoidAlgebra k G`
in the same way, and then define the convolution product on these.

When the domain is additive, this is used to define polynomials:
```
Polynomial R := AddMonoidAlgebra R ℕ
MvPolynomial σ α := AddMonoidAlgebra R (σ →₀ ℕ)
```

When the domain is multiplicative, e.g. a group, this will be used to define the group ring.

## Notation

We introduce the notation `R[A]` for `AddMonoidAlgebra R A`.

## Implementation note
Unfortunately because additive and multiplicative structures both appear in both cases,
it doesn't appear to be possible to make much use of `to_additive`, and we just settle for
saying everything twice.

Similarly, I attempted to just define
`k[G] := MonoidAlgebra k (Multiplicative G)`, but the definitional equality
`Multiplicative G = G` leaks through everywhere, and seems impossible to use.
-/

assert_not_exists NonUnitalAlgHom AlgEquiv

noncomputable section

open Finsupp hiding single

variable {ι R S G M N O : Type*}

/-! ### Multiplicative monoids -/

variable (R M) [Semiring R] in
/-- The monoid algebra over a semiring `R` generated by the monoid `M`.

It is the type of finite formal `R`-linear combinations of terms of `M`,
endowed with the convolution product. -/
structure MonoidAlgebra where
  /-- Construct an element of the monoid algebra `R[M]` from its coefficients `M →₀ R`. -/
  ofCoeff ::
  /-- The coefficients `M →₀ R` of an element of the monoid algebra `R[M]`. -/
  coeff : M →₀ R

namespace MonoidAlgebra

@[inherit_doc MonoidAlgebra]
scoped syntax:max (priority := high) term noWs "[" term "]" : term

macro_rules | `($R[$M]) => `(MonoidAlgebra $R $M)

/-- Unexpander for `MonoidAlgebra`. -/
@[scoped app_unexpander MonoidAlgebra]
def unexpander : Lean.PrettyPrinter.Unexpander
  | `($_ $R $M) => `($R[$M])
  | _ => throw ()

section Semiring
variable [Semiring R] {x y : R[M]} {r r₁ r₂ : R} {m m' m₁ m₂ : M}

lemma coeff_ofCoeff (x : M →₀ R) : (ofCoeff x).coeff = x := rfl
lemma ofCoeff_coeff (x : R[M]) : ofCoeff x.coeff = x := rfl

/-- `MonoidAlgebra.coeff` as an equiv. -/
@[simps!]
def coeffEquiv : R[M] ≃ (M →₀ R) where
  toFun := coeff
  invFun := ofCoeff
  left_inv _ := rfl
  right_inv _ := rfl

@[simp] lemma coeff_inj : x.coeff = y.coeff ↔ x = y := coeffEquiv.injective.eq_iff
lemma ofCoeff_inj {x y : M →₀ R} : ofCoeff x = ofCoeff y ↔ x = y := coeffEquiv.symm.injective.eq_iff

@[ext] alias ⟨ext, _⟩ := coeff_inj

instance inhabited : Inhabited R[M] := coeffEquiv.inhabited
instance nontrivial [Nontrivial R] [Nonempty M] : Nontrivial R[M] := coeffEquiv.nontrivial
instance unique [Subsingleton R] : Unique R[M] := coeffEquiv.unique

instance addCommMonoid : AddCommMonoid R[M] := coeffEquiv.addCommMonoid
instance instIsCancelAdd [IsCancelAdd R] : IsCancelAdd R[M] := coeffEquiv.isCancelAdd

/-- `MonoidAlgebra.single m r` for `m : M`, `r : R` is the element `rm : R[M]`. -/
def single (m : M) (r : R) : R[M] := .ofCoeff <| .single m r

section SMul

/-! ### Basic scalar multiplication instances

This section collects instances needed for the algebraic structure of `Polynomial`,
which is defined in terms of `MonoidAlgebra`.
Further results on scalar multiplication can be found in
`Mathlib/Algebra/MonoidAlgebra/Module.lean`.
-/

variable {A : Type*} [SMulZeroClass A R]

instance smulZeroClass : SMulZeroClass A R[M] := coeffEquiv.smulZeroClass _

@[simp] lemma coeff_smul (a : A) (x : R[M]) : coeff (a • x) = a • coeff x := rfl
@[simp] lemma ofCoeff_smul (a : A) (x : M →₀ R) : ofCoeff (a • x) = a • ofCoeff x := rfl
@[simp] lemma smul_single (a : A) (m : M) (r : R) : a • single m r = single m (a • r) := by
  ext; simp [single]

lemma smul_single' (r' : R) (m : M) (r : R) : r' • single m r = single m (r' * r) := smul_single ..

@[deprecated coeff_smul (since := "2025-08-15")]
lemma smul_apply (r : A) (m : M) (x : R[M]) : (r • x).coeff m = r • x.coeff m := rfl

instance distribSMul [DistribSMul N R] : DistribSMul N R[M] := coeffEquiv.distribSMul _

instance isScalarTower [SMulZeroClass N R] [SMulZeroClass O R] [SMul N O] [IsScalarTower N O R] :
    IsScalarTower N O R[M] := coeffEquiv.isScalarTower ..

instance smulCommClass [SMulZeroClass N R] [SMulZeroClass O R] [SMulCommClass N O R] :
    SMulCommClass N O R[M] := coeffEquiv.smulCommClass ..

instance isCentralScalar [SMulZeroClass N R] [SMulZeroClass Nᵐᵒᵖ R] [IsCentralScalar N R] :
    IsCentralScalar N R[M] := coeffEquiv.isCentralScalar _

end SMul

/-- `MonoidAlgebra.coeff` as an `AddEquiv`. -/
@[simps!]
def coeffAddEquiv : R[M] ≃+ (M →₀ R) := coeffEquiv.addEquiv

@[simp] lemma coeff_zero : coeff (0 : R[M]) = 0 := rfl
@[simp] lemma coeff_eq_zero : coeff x = 0 ↔ x = 0 := coeff_inj
@[simp] lemma coeff_add (x y : R[M]) : coeff (x + y) = coeff x + coeff y := rfl
@[simp] lemma coeff_sum (s : Finset ι) (f : ι → R[M]) :
    coeff (∑ i ∈ s, f i) = ∑ i ∈ s, coeff (f i) := map_sum coeffAddEquiv ..
@[simp] lemma coeff_finsuppSum [AddCommMonoid N] (f : ι →₀ N) (g : ι → N → R[M]) :
    coeff (f.sum g) = f.sum (fun i n ↦ coeff (g i n)) := map_finsuppSum coeffAddEquiv ..
@[simp] lemma ofCoeff_zero : (ofCoeff 0 : R[M]) = 0 := rfl
@[simp] lemma ofCoeff_eq_zero {x : M →₀ R} : ofCoeff x = 0 ↔ x = 0 := ofCoeff_inj
@[simp] lemma ofCoeff_add (x y : M →₀ R) : ofCoeff (x + y) = ofCoeff x + ofCoeff y := rfl
@[simp] lemma ofCoeff_sum (s : Finset ι) (f : ι → M →₀ R) :
    ofCoeff (∑ i ∈ s, f i) = ∑ i ∈ s, ofCoeff (f i) := map_sum coeffAddEquiv.symm ..
@[simp] lemma ofCoeff_finsuppSum [AddCommMonoid N] (f : ι →₀ N) (g : ι → N → M →₀ R) :
    ofCoeff (f.sum g) = f.sum (fun i n ↦ ofCoeff (g i n)) := map_finsuppSum coeffAddEquiv.symm ..

@[simp] lemma coeff_single (m : M) (r : R) : (single m r).coeff = .single m r := rfl

@[simp] lemma single_zero (m : M) : (single m 0 : R[M]) = 0 := by simp [single]

@[simp] lemma single_add (m : M) (r₁ r₂ : R) : single m (r₁ + r₂) = single m r₁ + single m r₂ := by
  simp [single]

@[deprecated coeff_add (since := "2025-08-15")]
lemma coe_add (f g : R[M]) : ⇑(f + g).coeff = f.coeff + g.coeff := rfl

/-- `MonoidAlgebra.single` as an `AddMonoidHom`.

TODO: Rename to `singleAddMonoidHom`. -/
@[simps]
def singleAddHom (m : M) : R →+ R[M] where
  toFun := single m
  map_zero' := single_zero _
  map_add' := single_add _

/-- If two additive homomorphisms from `R[M]` are equal on each `single r m`,
then they are equal. -/
lemma addMonoidHom_ext [AddZeroClass N] ⦃f g : R[M] →+ N⦄
    (h : ∀ m r, f (single m r) = g (single m r)) : f = g := by
  have : f.comp coeffAddEquiv.symm.toAddMonoidHom = g.comp coeffAddEquiv.symm.toAddMonoidHom :=
    Finsupp.addHom_ext h
  convert congr(($this).comp coeffAddEquiv.toAddMonoidHom)

/-- If two additive homomorphisms from `R[M]` are equal on each `single r m`, then they are equal.

We formulate this using equality of `AddMonoidHom`s so that `ext` tactic can apply a type-specific
extensionality lemma after this one.  E.g., if the fiber `M` is `ℕ` or `ℤ`, then it suffices to
verify `f (single a 1) = g (single a 1)`.

TODO: Rename to `addMonoidHom_ext'`. -/
@[ext high]
lemma addHom_ext' {N : Type*} [AddZeroClass N] ⦃f g : R[M] →+ N⦄
    (hfg : ∀ m, f.comp (singleAddHom m) = g.comp (singleAddHom m)) : f = g :=
  addMonoidHom_ext <| by simpa [DFunLike.ext_iff] using hfg

@[deprecated Finsupp.sum_single_index (since := "2025-08-14")]
lemma sum_single_index [AddCommMonoid N] {m : M} {r : R} {h : M → R → N} (h_zero : h m 0 = 0) :
    (single m r).coeff.sum h = h m r := by
  simp [h_zero]

@[simp] lemma sum_coeff_single (f : R[M]) : f.coeff.sum single = f := by ext; simp

@[deprecated (since := "2025-08-14")] alias sum_single := sum_coeff_single

@[deprecated Finsupp.single_apply (since := "2025-08-14")]
theorem single_apply {a a' : M} {b : R} [Decidable (a = a')] :
    (single a b).coeff a' = if a = a' then b else 0 :=
  Finsupp.single_apply

@[simp]
lemma single_eq_zero : single m r = 0 ↔ r = 0 := by simp [single]
lemma single_ne_zero : single m r ≠ 0 ↔ r ≠ 0 := by simp [single]

@[elab_as_elim]
lemma induction_linear {p : R[M] → Prop} (f : R[M]) (zero : p 0)
    (add : ∀ x y : R[M], p x → p y → p (x + y)) (single : ∀ m r, p (single m r)) : p f :=
  Finsupp.induction_linear (motive := (p <| ofCoeff ·)) f.coeff zero (fun _ _ ↦ add _ _)
    (fun _ _ ↦ single _ _)

section One
variable [One M]

/-- The unit of the multiplication is `single 1 1`,
i.e. the function that is `1` at `1` and `0` elsewhere. -/
instance one : One R[M] where one := single 1 1

lemma one_def : (1 : R[M]) = single 1 1 := rfl

@[simp] lemma coeff_one_one : (1 : R[M]).coeff 1 = 1 := by simp [one_def]

end One

section Mul
variable [Mul M]

/-- The multiplication in a monoid algebra. We make it irreducible so that Lean doesn't unfold
it trying to unify two things that are different. -/
@[irreducible] def mul' (x y : R[M]) : R[M] :=
  x.coeff.sum fun m₁ r₁ ↦ y.coeff.sum fun m₂ r₂ ↦ single (m₁ * m₂) (r₁ * r₂)

/-- The product of `x y : R[M]` is the finitely supported function whose value at `m` is the sum of
`x m₁ * y m₂` over all pairs `m₁, m₂` such that `m₁ * m₂ = m`.
(Think of the group ring of a group.) -/
instance instMul : Mul R[M] where mul := mul'

lemma mul_def (x y : R[M]) :
    x * y = x.coeff.sum fun m₁ r₁ ↦ y.coeff.sum fun m₂ r₂ ↦ single (m₁ * m₂) (r₁ * r₂) := by
  with_unfolding_all rfl

instance nonUnitalNonAssocSemiring : NonUnitalNonAssocSemiring R[M] where
  zero_mul := by simp [mul_def]
  mul_zero := by simp [mul_def]
  left_distrib := by classical simp [mul_def, mul_add, sum_add, sum_add_index]
  right_distrib := by classical simp [mul_def, add_mul, sum_add, sum_add_index]

lemma coeff_mul [DecidableEq M] (x y : R[M]) (m : M) :
    (x * y).coeff m =
      x.coeff.sum fun m₁ r₁ ↦ y.coeff.sum fun m₂ r₂ ↦ if m₁ * m₂ = m then r₁ * r₂ else 0 := by
  simp [mul_def, Finsupp.single_apply]

@[deprecated (since := "2025-08-15")] alias mul_apply := coeff_mul

open Finset in
lemma coeff_mul_antidiag (x y : R[M]) (m : M) (s : Finset (M × M))
    (hs : ∀ {p}, p ∈ s ↔ p.1 * p.2 = m) : (x * y).coeff m = ∑ p ∈ s, x.coeff p.1 * y.coeff p.2 := by
  classical
  let F (p : M × M) : R := if p.1 * p.2 = m then x.coeff p.1 * y.coeff p.2 else 0
  calc
    (x * y).coeff m = ∑ m₁ ∈ x.coeff.support, ∑ m₂ ∈ y.coeff.support, F (m₁, m₂) := coeff_mul ..
    _ = ∑ p ∈ x.coeff.support ×ˢ y.coeff.support with p.1 * p.2 = m, x.coeff p.1 * y.coeff p.2 := by
      rw [Finset.sum_filter, Finset.sum_product]
    _ = ∑ p ∈ s with p.1 ∈ x.coeff.support ∧ p.2 ∈ y.coeff.support, x.coeff p.1 * y.coeff p.2 := by
      congr! 1; ext; simp only [mem_filter, mem_product, hs, and_comm]
    _ = ∑ p ∈ s, x.coeff p.1 * y.coeff p.2 :=
      sum_subset (filter_subset _ _) fun p hps hp => by
        simp only [mem_filter, mem_support_iff, not_and, Classical.not_not] at hp ⊢
        by_cases h1 : x.coeff p.1 = 0
        · rw [h1, zero_mul]
        · rw [hp hps h1, mul_zero]

@[deprecated (since := "2025-08-16")] alias mul_apply_antidiagonal := coeff_mul_antidiag

@[simp]
lemma single_mul_single (m₁ m₂ : M) (r₁ r₂ : R) :
    single m₁ r₁ * single m₂ r₂ = single (m₁ * m₂) (r₁ * r₂) := by simp [mul_def]

lemma single_commute_single (hm : Commute m₁ m₂) (hr : Commute r₁ r₂) :
    Commute (single m₁ r₁) (single m₂ r₂) := by simp [Commute, SemiconjBy, hm.eq, hr.eq]

lemma single_commute (hm : ∀ m', Commute m m') (hr : ∀ r', Commute r r') (x : R[M]) :
    Commute (single m r) x := by
  have : AddMonoidHom.mulLeft (single m r) = AddMonoidHom.mulRight (single m r) := by
    ext m' r' : 2; exact single_commute_single (hm m') (hr r')
  exact congr($this x)

private lemma coeff_mul_single_aux (H : ∀ m' ∈ x.coeff.support, m' * m = m₁ ↔ m' = m₂) :
    (x * single m r).coeff m₁ = x.coeff m₂ * r := by
  classical
  calc
    (x * single m r).coeff m₁
    _ = x.coeff.sum fun m' r' ↦ if m' * m = m₁ then r' * r else 0 := by simp [coeff_mul]
    _ = x.coeff.sum fun m' r' ↦ if m' = m₂ then r' * r else 0 := by congr! 2; simp [*]
    _ = x.coeff m₂ * r := by simp +contextual [Finsupp.sum_eq_single m₂]

private lemma coeff_single_mul_aux (H : ∀ m' ∈ x.coeff.support, m * m' = m₁ ↔ m' = m₂) :
    (single m r * x).coeff m₁ = r * x.coeff m₂ := by
  classical
  calc
    (single m r * x).coeff m₁
    _ = x.coeff.sum fun m' r' ↦ if m * m' = m₁ then r * r' else 0 := by simp [coeff_mul]
    _ = x.coeff.sum fun m' r' ↦ if m' = m₂ then r * r' else 0 := by congr! 2; simp [*]
    _ = r * x.coeff m₂ := by simp +contextual [Finsupp.sum_eq_single m₂]

lemma coeff_mul_single_of_forall_mul_ne (r : R) (x : R[M]) (h : ∀ d, d * m ≠ m') :
    (x * single m r).coeff m' = 0 := by classical simp [coeff_mul, h]

lemma coeff_single_mul_of_forall_mul_ne (r : R) (x : R[M]) (h : ∀ d, m * d ≠ m') :
    (single m r * x).coeff m' = 0 := by classical simp [coeff_mul, h]

@[deprecated coeff_mul_single_of_forall_mul_ne (since := "2025-08-16")]
lemma mul_single_apply_of_not_exists_mul (r : R) {g g' : M} (x : R[M])
    (h : ¬∃ d, g' = d * g) : (x * single g r).coeff g' = 0 :=
  coeff_mul_single_of_forall_mul_ne _ _ <| by simpa [eq_comm] using h

@[deprecated coeff_single_mul_of_forall_mul_ne (since := "2025-08-16")]
lemma single_mul_apply_of_not_exists_mul (r : R) {g g' : M} (x : R[M])
    (h : ¬∃ d, g' = g * d) : (single g r * x).coeff g' = 0 :=
  coeff_single_mul_of_forall_mul_ne _ _ <| by simpa [eq_comm] using h

variable (R M) in
/-- The embedding of a magma into its magma algebra. -/
@[simps]
def ofMagma : M →ₙ* R[M] where
  toFun a := single a 1
  map_mul' a b := by ext; simp [mul_def, Finsupp.sum_single_index]

end Mul

section Semigroup
variable [Semigroup M]

instance nonUnitalSemiring : NonUnitalSemiring R[M] where
  mul_assoc := by simp [mul_def, sum_sum_index, mul_add, add_mul, mul_assoc]

end Semigroup

section MulOneClass
variable [MulOneClass M]

instance nonAssocSemiring : NonAssocSemiring R[M] where
  natCast n := single 1 n
  natCast_zero := by simp
  natCast_succ := by simp [one_def]
  one_mul := by simp [mul_def, one_def]
  mul_one := by simp [mul_def, one_def]

theorem natCast_def (n : ℕ) : (n : R[M]) = single (1 : M) (n : R) :=
  rfl

lemma coeff_mul_single_one (x : R[M]) (r : R) (m : M) : (x * single 1 r).coeff m = x.coeff m * r :=
  x.coeff_mul_single_aux (by simp)

lemma coeff_single_one_mul (x : R[M]) (r : R) (m : M) : (single 1 r * x).coeff m = r * x.coeff m :=
  x.coeff_single_mul_aux (by simp)

@[deprecated (since := "2025-08-16")] alias mul_single_one_apply := coeff_mul_single_one
@[deprecated (since := "2025-08-16")] alias single_one_mul_apply := coeff_single_one_mul

variable (R M) in
/-- The embedding of a unital magma into its magma algebra. -/
@[simps]
def of : M →* R[M] where
  __ := ofMagma R M
  map_one' := rfl

lemma of_injective [Nontrivial R] : Function.Injective (of R M) := fun a b h ↦ by
  simpa [← coeff_inj, Finsupp.single_eq_single_iff] using h

lemma of_commute (h : ∀ m', Commute m m') (f : R[M]) : Commute (of R M m) f :=
  single_commute h .one_left f

/-- `MonoidAlgebra.single` as a `MonoidHom` from the product type into the monoid algebra.

Note the order of the elements of the product are reversed compared to the arguments of
`MonoidAlgebra.single`. -/
@[simps]
def singleHom : R × M →* R[M] where
  toFun a := single a.2 a.1
  map_one' := rfl
  map_mul' _a _b := by simp

/-- `MonoidAlgebra.single 1` as a `RingHom` -/
@[simps]
def singleOneRingHom : R →+* R[M] where
  __ := singleAddHom 1
  map_one' := rfl
  map_mul' := by simp

/-- If two ring homomorphisms from `R[M]` are equal on all `single a 1` and `single 1 b`,
then they are equal. -/
lemma ringHom_ext {f g : R[M] →+* R}
    (h₁ : ∀ r, f (single 1 r) = g (single 1 r)) (h_of : ∀ m, f (single m 1) = g (single m 1)) :
    f = g :=
  RingHom.coe_addMonoidHom_injective <| addMonoidHom_ext fun m r ↦ by
    simpa [← map_mul] using congr($(h₁ r) * $(h_of m))

/-- If two ring homomorphisms from `R[M]` are equal on all `single a 1`
and `single 1 b`, then they are equal.

See note [partially-applied ext lemmas]. -/
@[ext high]
lemma ringHom_ext' {f g : R[M] →+* R} (h₁ : f.comp singleOneRingHom = g.comp singleOneRingHom)
    (h_of : (f : R[M] →* R).comp (of R M) = (g : R[M] →* R).comp (of R M)) : f = g :=
  ringHom_ext (by simpa [DFunLike.ext_iff] using h₁) (by simpa [DFunLike.ext_iff] using h_of)

end MulOneClass

section Monoid
variable [Monoid M]

instance semiring : Semiring R[M] where

@[simp]
lemma single_pow (m : M) (r : R) : ∀ n : ℕ, single m r ^ n = single (m ^ n) (r ^ n)
  | 0 => by simp [one_def]
  | n + 1 => by simp [pow_succ, single_pow _ _ n]

lemma induction_on {p : R[M] → Prop} (x : R[M])
    (hM : ∀ m, p (of R M m)) (hadd : ∀ x y : R[M], p x → p y → p (x + y))
    (hsmul : ∀ (r : R) (x), p x → p (r • x)) : p x :=
  Finsupp.induction_linear (motive := fun x ↦ p (ofCoeff x)) x.coeff
    (by simpa using hsmul 0 (of R M 1) (hM 1))
    (fun x y hf hg => hadd (ofCoeff x) (ofCoeff y) hf hg)
    fun m r ↦ by simpa using hsmul r (of R M m) (hM m)

instance isLocalHom_singleOneRingHom : IsLocalHom (singleOneRingHom (R := R) (M := M)) where
  map_nonunit := by
    simp_rw [isUnit_iff_exists]
    rintro a ⟨x, hax, hxa⟩
    refine ⟨x.coeff 1, ?_, ?_⟩
    · simpa [coeff_single_one_mul] using congr(($hax).coeff 1)
    · simpa [coeff_mul_single_one] using congr(($hxa).coeff 1)

end Monoid

section Group
variable [Group G]

@[simp]
lemma coeff_mul_single (x : R[G]) (r : R) (g h : G) :
    (x * single g r).coeff h = x.coeff (h * g⁻¹) * r :=
  coeff_mul_single_aux <| by simp [eq_mul_inv_iff_mul_eq]

@[simp]
lemma coeff_single_mul (x : R[G]) (r : R) (g h : G) :
    (single g r * x).coeff h = r * x.coeff (g⁻¹ * h) :=
  coeff_single_mul_aux <| by simp [eq_inv_mul_iff_mul_eq]

lemma coeff_mul_left (x y : R[G]) (g : G) :
    (x * y).coeff g = x.coeff.sum fun h r ↦ r * y.coeff (h⁻¹ * g) := by
  classical rw [coeff_mul]; congr! 1; simp +contextual [← eq_inv_mul_iff_mul_eq]

lemma coeff_mul_right (x y : R[G]) (g : G) :
    (x * y).coeff g = y.coeff.sum fun h r ↦ x.coeff (g * h⁻¹) * r := by
  classical rw [coeff_mul, Finsupp.sum_comm]; congr! 1; simp +contextual [← eq_mul_inv_iff_mul_eq]

@[deprecated (since := "2025-08-16")] alias mul_single_apply := coeff_mul_single
@[deprecated (since := "2025-08-16")] alias single_mul_apply := coeff_single_mul
@[deprecated (since := "2025-08-16")] alias mul_apply_left := coeff_mul_left
@[deprecated (since := "2025-08-16")] alias mul_apply_right := coeff_mul_right

end Group
end Semiring

section CommSemiring
variable [CommSemiring R]

instance nonUnitalCommSemiring [CommSemigroup M] : NonUnitalCommSemiring R[M] where
  mul_comm f g := by simp [mul_def, Finsupp.sum, mul_comm, f.coeff.support.sum_comm]

lemma single_one_comm [MulOneClass M] (r : R) (f : R[M]) :
    single (1 : M) r * f = f * single (1 : M) r :=
  single_commute .one_left (.all _) f

section CommMonoid
variable [CommMonoid M]

instance commSemiring : CommSemiring R[M] where

open Finset in
lemma prod_single (s : Finset ι) (m : ι → M) (r : ι → R) :
    ∏ i ∈ s, single (m i) (r i) = single (∏ i ∈ s, m i) (∏ i ∈ s, r i) :=
  Finset.cons_induction_on s rfl fun i s hi ih ↦ by
    rw [prod_cons, ih, single_mul_single, prod_cons, prod_cons]

end CommMonoid
end CommSemiring

section Ring
variable [Ring R]

instance addCommGroup : AddCommGroup R[M] := coeffEquiv.addCommGroup

@[simp] lemma coeff_neg (x : R[M]) : (-x).coeff = -x.coeff := rfl
@[simp] lemma ofCoeff_neg (x : M →₀ R) : ofCoeff (-x) = -ofCoeff x := rfl

@[simp] lemma single_neg (m : M) (r : R) : single m (-r) = -single m r := by simp [single]

instance nonUnitalNonAssocRing [Mul M] : NonUnitalNonAssocRing R[M] where
instance nonUnitalRing [Semigroup M] : NonUnitalRing R[M] where

instance nonAssocRing [MulOneClass M] : NonAssocRing R[M] where
  intCast z := single 1 z
  intCast_ofNat n := by simp [natCast_def]
  intCast_negSucc n := by simp [natCast_def, one_def]

lemma intCast_def [MulOneClass M] (z : ℤ) : (z : R[M]) = single 1 (z : R) := rfl

instance ring [Monoid M] : Ring R[M] where

@[deprecated coeff_neg (since := "2025-08-15")]
lemma neg_apply (m : M) (x : R[M]) : (-x).coeff m = -x.coeff m := rfl

end Ring

section CommRing
variable [CommRing R]

instance nonUnitalCommRing [CommSemigroup M] : NonUnitalCommRing R[M] where
instance commRing [CommMonoid M] : CommRing R[M] where

end CommRing
end MonoidAlgebra

/-! ### Additive monoids -/

variable (R M) [Semiring R] in
/-- The monoid algebra over a semiring `R` generated by the additive monoid `M`, denoted by `R[M]`.

It is the type of finite formal `R`-linear combinations of terms of `M`,
endowed with the convolution product. -/
def AddMonoidAlgebra := MonoidAlgebra R (Multiplicative M)

namespace AddMonoidAlgebra

@[inherit_doc AddMonoidAlgebra]
scoped syntax:max (priority := high) term noWs "[" term "]" : term

macro_rules | `($R[$M]) => `(AddMonoidAlgebra $R $M)

/-- Unexpander for `AddMonoidAlgebra`. -/
@[scoped app_unexpander AddMonoidAlgebra]
def unexpander : Lean.PrettyPrinter.Unexpander
  | `($_ $R $M) => `($R[$M])
  | _ => throw ()

section Semiring
variable [Semiring R] {x y : R[M]} {r r₁ r₂ : R} {m m' m₁ m₂ : M}

/-- Construct an element of the monoid algebra `R[M]` from its coefficients `M →₀ R`. -/
def coeff (x : R[M]) : M →₀ R := MonoidAlgebra.coeff x

/-- The coefficients `M →₀ R` of an element of the monoid algebra `R[M]`. -/
def ofCoeff (x : M →₀ R) : R[M] := MonoidAlgebra.ofCoeff x

-- These two lemmas are simp while the corresponding `MonoidAlgebra` ones are not,
-- because simp can already prove those through eta reduction on `MonoidAlgebra`.
@[simp] lemma coeff_ofCoeff (x : M →₀ R) : (ofCoeff x).coeff = x := rfl
@[simp] lemma ofCoeff_coeff (x : R[M]) : ofCoeff x.coeff = x := rfl

/-- `AddMonoidAlgebra.coeff` as an equiv. -/
@[simps!]
def coeffEquiv : R[M] ≃ (M →₀ R) where
  toFun := coeff
  invFun := ofCoeff
  left_inv _ := rfl
  right_inv _ := rfl

@[simp] lemma coeff_inj : x.coeff = y.coeff ↔ x = y := coeffEquiv.injective.eq_iff
@[simp] lemma ofCoeff_inj {x y : M →₀ R} : ofCoeff x = ofCoeff y ↔ x = y :=
  coeffEquiv.symm.injective.eq_iff

@[ext] alias ⟨ext, _⟩ := coeff_inj

instance inhabited : Inhabited R[M] := coeffEquiv.inhabited
instance nontrivial [Nontrivial R] [Nonempty M] : Nontrivial R[M] := coeffEquiv.nontrivial
instance unique [Subsingleton R] : Unique R[M] := coeffEquiv.unique

instance addCommMonoid : AddCommMonoid R[M] := coeffEquiv.addCommMonoid
instance instIsCancelAdd [IsCancelAdd R] : IsCancelAdd R[M] := coeffEquiv.isCancelAdd

/-- `AddMonoidAlgebra.single m r` for `m : M`, `r : R` is the element `rm : R[M]`. -/
def single (m : M) (r : R) : R[M] := .ofCoeff <| .single m r

section SMul

/-! ### Basic scalar multiplication instances

This section collects instances needed for the algebraic structure of `Polynomial`,
which is defined in terms of `AddMonoidAlgebra`.
Further results on scalar multiplication can be found in
`Mathlib/Algebra/AddMonoidAlgebra/Module.lean`.
-/

variable {A : Type*} [SMulZeroClass A R]

instance smulZeroClass : SMulZeroClass A R[M] := coeffEquiv.smulZeroClass _

@[simp] lemma coeff_smul (a : A) (x : R[M]) : coeff (a • x) = a • coeff x := rfl
@[simp] lemma ofCoeff_smul (a : A) (x : M →₀ R) : ofCoeff (a • x) = a • ofCoeff x := rfl
@[simp] lemma smul_single (a : A) (m : M) (r : R) : a • single m r = single m (a • r) := by
  ext; simp [single]

lemma smul_single' (r' : R) (m : M) (r : R) : r' • single m r = single m (r' * r) := smul_single ..

@[deprecated coeff_smul (since := "2025-08-15")]
lemma smul_apply (r : A) (m : M) (x : R[M]) : (r • x).coeff m = r • x.coeff m := rfl

instance distribSMul [DistribSMul N R] : DistribSMul N R[M] := coeffEquiv.distribSMul _

instance isScalarTower [SMulZeroClass N R] [SMulZeroClass O R] [SMul N O] [IsScalarTower N O R] :
    IsScalarTower N O R[M] := coeffEquiv.isScalarTower ..

instance smulCommClass [SMulZeroClass N R] [SMulZeroClass O R] [SMulCommClass N O R] :
    SMulCommClass N O R[M] := coeffEquiv.smulCommClass ..

instance isCentralScalar [SMulZeroClass N R] [SMulZeroClass Nᵐᵒᵖ R] [IsCentralScalar N R] :
    IsCentralScalar N R[M] := coeffEquiv.isCentralScalar _

end SMul

/-- `AddMonoidAlgebra.coeff` as an `AddEquiv`. -/
@[simps!]
def coeffAddEquiv : R[M] ≃+ (M →₀ R) := coeffEquiv.addEquiv

@[simp] lemma coeff_zero : coeff (0 : R[M]) = 0 := rfl
@[simp] lemma coeff_eq_zero : coeff x = 0 ↔ x = 0 := coeff_inj
@[simp] lemma coeff_add (x y : R[M]) : coeff (x + y) = coeff x + coeff y := rfl
@[simp] lemma coeff_sum (s : Finset ι) (f : ι → R[M]) :
    coeff (∑ i ∈ s, f i) = ∑ i ∈ s, coeff (f i) := map_sum coeffAddEquiv ..
@[simp] lemma coeff_finsuppSum [AddCommMonoid N] (f : ι →₀ N) (g : ι → N → R[M]) :
    coeff (f.sum g) = f.sum (fun i n ↦ coeff (g i n)) := map_finsuppSum coeffAddEquiv ..
@[simp] lemma ofCoeff_zero : (ofCoeff 0 : R[M]) = 0 := rfl
@[simp] lemma ofCoeff_eq_zero {x : M →₀ R} : ofCoeff x = 0 ↔ x = 0 := ofCoeff_inj
@[simp] lemma ofCoeff_add (x y : M →₀ R) : ofCoeff (x + y) = ofCoeff x + ofCoeff y := rfl
@[simp] lemma ofCoeff_sum (s : Finset ι) (f : ι → M →₀ R) :
    ofCoeff (∑ i ∈ s, f i) = ∑ i ∈ s, ofCoeff (f i) := map_sum coeffAddEquiv.symm ..
@[simp] lemma ofCoeff_finsuppSum [AddCommMonoid N] (f : ι →₀ N) (g : ι → N → M →₀ R) :
    ofCoeff (f.sum g) = f.sum (fun i n ↦ ofCoeff (g i n)) := map_finsuppSum coeffAddEquiv.symm ..

@[simp] lemma coeff_single (m : M) (r : R) : (single m r).coeff = .single m r := rfl

@[simp] lemma single_zero (m : M) : (single m 0 : R[M]) = 0 := by simp [single]

@[simp] lemma single_add (m : M) (r₁ r₂ : R) : single m (r₁ + r₂) = single m r₁ + single m r₂ := by
  simp [single]

@[deprecated coeff_add (since := "2025-08-15")]
lemma coe_add (f g : R[M]) : ⇑(f + g).coeff = f.coeff + g.coeff := rfl

variable (R M) in
/-- Embedding of a magma with zero `M`, into its magma algebra, having `M` as source. -/
def of' (m : M) : R[M] := single m 1

@[simp] lemma of'_apply (m : M) : of' R M m = single m 1 := rfl

/-- `AddMonoidAlgebra.single` as an `AddMonoidHom`.

TODO: Rename to `singleAddMonoidHom`. -/
@[simps]
def singleAddHom (m : M) : R →+ R[M] where
  toFun := single m
  map_zero' := single_zero _
  map_add' := single_add _

/-- If two additive homomorphisms from `R[M]` are equal on each `single r m`,
then they are equal. -/
lemma addMonoidHom_ext [AddZeroClass N] ⦃f g : R[M] →+ N⦄
    (h : ∀ m r, f (single m r) = g (single m r)) : f = g := by
  have : f.comp coeffAddEquiv.symm.toAddMonoidHom = g.comp coeffAddEquiv.symm.toAddMonoidHom :=
    Finsupp.addHom_ext h
  convert congr(($this).comp coeffAddEquiv.toAddMonoidHom)

/-- If two additive homomorphisms from `R[M]` are equal on each `single r m`, then they are equal.

We formulate this using equality of `AddMonoidHom`s so that `ext` tactic can apply a type-specific
extensionality lemma after this one.  E.g., if the fiber `M` is `ℕ` or `ℤ`, then it suffices to
verify `f (single a 1) = g (single a 1)`.

TODO: Rename to `addMonoidHom_ext'`. -/
@[ext high]
lemma addHom_ext' {N : Type*} [AddZeroClass N] ⦃f g : R[M] →+ N⦄
    (hfg : ∀ m, f.comp (singleAddHom m) = g.comp (singleAddHom m)) : f = g :=
  addMonoidHom_ext <| by simpa [DFunLike.ext_iff] using hfg

@[deprecated Finsupp.sum_single_index (since := "2025-08-14")]
lemma sum_single_index [AddCommMonoid N] {m : M} {r : R} {h : M → R → N} (h_zero : h m 0 = 0) :
    (single m r).coeff.sum h = h m r := by
  simp [h_zero]

@[simp] lemma sum_coeff_single (f : R[M]) : f.coeff.sum single = f := by ext; simp

@[deprecated (since := "2025-08-14")] alias sum_single := sum_coeff_single

@[deprecated Finsupp.single_apply (since := "2025-08-14")]
theorem single_apply {a a' : M} {b : R} [Decidable (a = a')] :
    (single a b).coeff a' = if a = a' then b else 0 :=
  Finsupp.single_apply

@[simp]
lemma single_eq_zero : single m r = 0 ↔ r = 0 := by simp [single]
lemma single_ne_zero : single m r ≠ 0 ↔ r ≠ 0 := by simp [single]

@[elab_as_elim]
lemma induction_linear {p : R[M] → Prop} (f : R[M]) (zero : p 0)
    (add : ∀ x y : R[M], p x → p y → p (x + y)) (single : ∀ m r, p (single m r)) : p f :=
  Finsupp.induction_linear (motive := (p <| ofCoeff ·)) f.coeff zero (fun _ _ ↦ add _ _)
    (fun _ _ ↦ single _ _)

section Zero
variable [Zero M]

/-- The unit of the multiplication is `single 0 1`,
i.e. the function that is `1` at `0` and `0` elsewhere. -/
instance one : One R[M] where one := single 0 1

lemma one_def : (1 : R[M]) = single 0 1 := rfl

@[simp] lemma coeff_one_one : (1 : R[M]).coeff 0 = 1 := by simp [one_def]

end Zero

section Add
variable [Add M]

/-- The multiplication in a monoid algebra. We make it irreducible so that Lean doesn't unfold
it trying to unify two things that are different. -/
@[irreducible] def mul' (x y : R[M]) : R[M] :=
  x.coeff.sum fun m₁ r₁ ↦ y.coeff.sum fun m₂ r₂ ↦ single (m₁ + m₂) (r₁ * r₂)

/-- The product of `x y : R[M]` is the finitely supported function whose value at `m` is the sum of
`x m₁ * y m₂` over all pairs `m₁, m₂` such that `m₁ + m₂ = m`.
(Think of the group ring of a group.) -/
instance instMul : Mul R[M] where mul := mul'

lemma mul_def (x y : R[M]) :
    x * y = x.coeff.sum fun m₁ r₁ ↦ y.coeff.sum fun m₂ r₂ ↦ single (m₁ + m₂) (r₁ * r₂) := by
  with_unfolding_all rfl

instance nonUnitalNonAssocSemiring : NonUnitalNonAssocSemiring R[M] where
  zero_mul := by simp [mul_def]
  mul_zero := by simp [mul_def]
  left_distrib := by classical simp [mul_def, mul_add, sum_add, sum_add_index]
  right_distrib := by classical simp [mul_def, add_mul, sum_add, sum_add_index]

lemma coeff_mul [DecidableEq M] (x y : R[M]) (m : M) :
    (x * y).coeff m =
      x.coeff.sum fun m₁ r₁ ↦ y.coeff.sum fun m₂ r₂ ↦ if m₁ + m₂ = m then r₁ * r₂ else 0 := by
  simp [mul_def, Finsupp.single_apply]

@[deprecated (since := "2025-08-15")] alias mul_apply := coeff_mul

open Finset in
lemma coeff_mul_antidiag (x y : R[M]) (m : M) (s : Finset (M × M))
    (hs : ∀ {p}, p ∈ s ↔ p.1 + p.2 = m) : (x * y).coeff m = ∑ p ∈ s, x.coeff p.1 * y.coeff p.2 := by
  classical
  let F (p : M × M) : R := if p.1 + p.2 = m then x.coeff p.1 * y.coeff p.2 else 0
  calc
    (x * y).coeff m = ∑ m₁ ∈ x.coeff.support, ∑ m₂ ∈ y.coeff.support, F (m₁, m₂) := coeff_mul ..
    _ = ∑ p ∈ x.coeff.support ×ˢ y.coeff.support with p.1 + p.2 = m, x.coeff p.1 * y.coeff p.2 := by
      rw [Finset.sum_filter, Finset.sum_product]
    _ = ∑ p ∈ s with p.1 ∈ x.coeff.support ∧ p.2 ∈ y.coeff.support, x.coeff p.1 * y.coeff p.2 := by
      congr! 1; ext; simp only [mem_filter, mem_product, hs, and_comm]
    _ = ∑ p ∈ s, x.coeff p.1 * y.coeff p.2 :=
      sum_subset (filter_subset _ _) fun p hps hp => by
        simp only [mem_filter, mem_support_iff, not_and, Classical.not_not] at hp ⊢
        by_cases h1 : x.coeff p.1 = 0
        · rw [h1, zero_mul]
        · rw [hp hps h1, mul_zero]

@[deprecated (since := "2025-08-16")] alias mul_apply_antidiagonal := coeff_mul_antidiag

@[simp]
lemma single_mul_single (m₁ m₂ : M) (r₁ r₂ : R) :
    single m₁ r₁ * single m₂ r₂ = single (m₁ + m₂) (r₁ * r₂) := by simp [mul_def]

lemma single_commute_single (hm : AddCommute m₁ m₂) (hr : Commute r₁ r₂) :
    Commute (single m₁ r₁) (single m₂ r₂) := by simp [Commute, SemiconjBy, hm.eq, hr.eq]

lemma single_commute (hm : ∀ m', AddCommute m m') (hr : ∀ r', Commute r r') (x : R[M]) :
    Commute (single m r) x := by
  have : AddMonoidHom.mulLeft (single m r) = AddMonoidHom.mulRight (single m r) := by
    ext m' r' : 2; exact single_commute_single (hm m') (hr r')
  exact congr($this x)

private lemma coeff_mul_single_aux (H : ∀ m' ∈ x.coeff.support, m' + m = m₁ ↔ m' = m₂) :
    (x * single m r).coeff m₁ = x.coeff m₂ * r := by
  classical
  calc
    (x * single m r).coeff m₁
    _ = x.coeff.sum fun m' r' ↦ if m' + m = m₁ then r' * r else 0 := by simp [coeff_mul]
    _ = x.coeff.sum fun m' r' ↦ if m' = m₂ then r' * r else 0 := by congr! 2; simp [*]
    _ = x.coeff m₂ * r := by simp +contextual [Finsupp.sum_eq_single m₂]

private lemma coeff_single_mul_aux (H : ∀ m' ∈ x.coeff.support, m + m' = m₁ ↔ m' = m₂) :
    (single m r * x).coeff m₁ = r * x.coeff m₂ := by
  classical
  calc
    (single m r * x).coeff m₁
    _ = x.coeff.sum fun m' r' ↦ if m + m' = m₁ then r * r' else 0 := by simp [coeff_mul]
    _ = x.coeff.sum fun m' r' ↦ if m' = m₂ then r * r' else 0 := by congr! 2; simp [*]
    _ = r * x.coeff m₂ := by simp +contextual [Finsupp.sum_eq_single m₂]

lemma coeff_mul_single_of_forall_add_ne (r : R) (x : R[M]) (h : ∀ d, d + m ≠ m') :
    (x * single m r).coeff m' = 0 := by classical simp [coeff_mul, h]

lemma coeff_single_mul_of_forall_add_ne (r : R) (x : R[M]) (h : ∀ d, m + d ≠ m') :
    (single m r * x).coeff m' = 0 := by classical simp [coeff_mul, h]

@[deprecated coeff_mul_single_of_forall_add_ne (since := "2025-08-16")]
lemma mul_single_apply_of_not_exists_add (r : R) {g g' : M} (x : R[M]) (h : ¬∃ d, g' = d + g) :
    (x * single g r).coeff g' = 0 :=
  coeff_mul_single_of_forall_add_ne _ _ <| by simpa [eq_comm] using h

@[deprecated coeff_single_mul_of_forall_add_ne (since := "2025-08-16")]
lemma single_mul_apply_of_not_exists_add (r : R) {g g' : M} (x : R[M]) (h : ¬∃ d, g' = g + d) :
    (single g r * x).coeff g' = 0 :=
  coeff_single_mul_of_forall_add_ne _ _ <| by simpa [eq_comm] using h

variable (R M) in
/-- The embedding of a magma into its magma algebra. -/
@[simps]
def ofMagma : Multiplicative M →ₙ* R[M] where
  toFun a := single a.toAdd 1
  map_mul' a b := by ext; simp [mul_def, Finsupp.sum_single_index]

end Add

section AddSemigroup
variable [AddSemigroup M]

instance nonUnitalSemiring : NonUnitalSemiring R[M] where
  mul_assoc := by simp [mul_def, sum_sum_index, mul_add, add_mul, add_assoc, mul_assoc]

end AddSemigroup

section AddZeroClass
variable [AddZeroClass M]

instance nonAssocSemiring : NonAssocSemiring R[M] where
  natCast n := single 0 n
  natCast_zero := by simp
  natCast_succ := by simp [one_def]
  one_mul := by simp [mul_def, one_def]
  mul_one := by simp [mul_def, one_def]

lemma natCast_def (n : ℕ) : (n : R[M]) = single (0 : M) (n : R) := rfl

lemma coeff_mul_single_zero (x : R[M]) (r : R) (m : M) : (x * single 0 r).coeff m = x.coeff m * r :=
  x.coeff_mul_single_aux (by simp)

lemma coeff_single_zero_mul (x : R[M]) (r : R) (m : M) : (single 0 r * x).coeff m = r * x.coeff m :=
  x.coeff_single_mul_aux (by simp)

@[deprecated (since := "2025-08-16")] alias mul_single_zero_apply := coeff_mul_single_zero
@[deprecated (since := "2025-08-16")] alias single_zero_mul_apply := coeff_single_zero_mul

variable (R M) in
/-- The embedding of a unital magma into its magma algebra. -/
@[simps]
def of : Multiplicative M →* R[M] where
  __ := ofMagma R M
  map_one' := rfl

lemma of'_eq_of (m : M) : of' R M m = of R M (.ofAdd m) := rfl

lemma of_injective [Nontrivial R] : Function.Injective (of R M) := fun a b h ↦ by
  simpa [← coeff_inj, Finsupp.single_eq_single_iff] using h

lemma of_commute (h : ∀ m', AddCommute m m') (f : R[M]) : Commute (of R M m) f :=
  single_commute h .one_left f

lemma of'_commute (h : ∀ m', AddCommute m m') (f : R[M]) : Commute (of' R M m) f := of_commute h f

/-- `AddMonoidAlgebra.single` as a `MonoidHom` from the product type into the monoid algebra.

Note the order of the elements of the product are reversed compared to the arguments of
`AddMonoidAlgebra.single`. -/
@[simps]
def singleHom : R × Multiplicative M →* R[M] where
  toFun a := single a.2.toAdd a.1
  map_one' := rfl
  map_mul' _a _b := by simp

/-- `MonoidAlgebra.single 0` as a `RingHom` -/
@[simps]
def singleZeroRingHom : R →+* R[M] where
  __ := singleAddHom 0
  map_one' := rfl
  map_mul' := by simp

/-- If two ring homomorphisms from `R[M]` are equal on all `single a 1` and `single 0 b`,
then they are equal. -/
lemma ringHom_ext {f g : R[M] →+* R}
    (h₁ : ∀ r, f (single 0 r) = g (single 0 r)) (h_of : ∀ m, f (single m 1) = g (single m 1)) :
    f = g :=
  RingHom.coe_addMonoidHom_injective <| addMonoidHom_ext fun m r ↦ by
    simpa [← map_mul] using congr($(h₁ r) * $(h_of m))

/-- If two ring homomorphisms from `R[M]` are equal on all `single a 1`
and `single 0 b`, then they are equal.

See note [partially-applied ext lemmas]. -/
@[ext high]
lemma ringHom_ext' {f g : R[M] →+* R} (h₁ : f.comp singleZeroRingHom = g.comp singleZeroRingHom)
    (h_of : (f : R[M] →* R).comp (of R M) = (g : R[M] →* R).comp (of R M)) : f = g :=
  ringHom_ext (by simpa [DFunLike.ext_iff] using h₁) (by simpa [DFunLike.ext_iff] using h_of)

end AddZeroClass

section AddMonoid
variable [AddMonoid M]

instance semiring : Semiring R[M] where

@[simp]
lemma single_pow (m : M) (r : R) : ∀ n : ℕ, single m r ^ n = single (n • m) (r ^ n)
  | 0 => by simp [one_def]
  | n + 1 => by simp [succ_nsmul, pow_succ, single_pow _ _ n]

lemma induction_on {p : R[M] → Prop} (x : R[M])
    (hM : ∀ m, p (of R M m)) (hadd : ∀ x y : R[M], p x → p y → p (x + y))
    (hsmul : ∀ (r : R) (x), p x → p (r • x)) : p x :=
  Finsupp.induction_linear (motive := fun x ↦ p (ofCoeff x)) x.coeff
    (by simpa using hsmul 0 (of R M 1) (hM 1))
    (fun x y hf hg => hadd (ofCoeff x) (ofCoeff y) hf hg)
    fun m r ↦ by simpa using hsmul r (of R M m) (hM m)

instance isLocalHom_singleZeroRingHom : IsLocalHom (singleZeroRingHom (R := R) (M := M)) where
  map_nonunit := by
    simp_rw [isUnit_iff_exists]
    rintro a ⟨x, hax, hxa⟩
    refine ⟨x.coeff 0, ?_, ?_⟩
    · simpa [coeff_single_zero_mul] using congr(($hax).coeff 0)
    · simpa [coeff_mul_single_zero] using congr(($hxa).coeff 0)

end AddMonoid

section AddGroup
variable [AddGroup G]

@[simp]
lemma coeff_mul_single (x : R[G]) (r : R) (g h : G) :
    (x * single g r).coeff h = x.coeff (h - g) * r :=
  coeff_mul_single_aux <| by simp [eq_sub_iff_add_eq]

@[simp]
lemma coeff_single_mul (x : R[G]) (r : R) (g h : G) :
    (single g r * x).coeff h = r * x.coeff (-g + h) :=
  coeff_single_mul_aux <| by simp [eq_neg_add_iff_add_eq]

lemma coeff_mul_left (x y : R[G]) (g : G) :
    (x * y).coeff g = x.coeff.sum fun h r ↦ r * y.coeff (-h + g) := by
  classical rw [coeff_mul]; congr! 1; simp +contextual [← eq_neg_add_iff_add_eq]

lemma coeff_mul_right (x y : R[G]) (g : G) :
    (x * y).coeff g = y.coeff.sum fun h r ↦ x.coeff (g - h) * r := by
  classical rw [coeff_mul, Finsupp.sum_comm]; congr! 1; simp +contextual [← eq_sub_iff_add_eq]

@[deprecated (since := "2025-08-16")] alias mul_single_apply := coeff_mul_single
@[deprecated (since := "2025-08-16")] alias single_mul_apply := coeff_single_mul
@[deprecated (since := "2025-08-16")] alias mul_apply_left := coeff_mul_left
@[deprecated (since := "2025-08-16")] alias mul_apply_right := coeff_mul_right

end AddGroup
end Semiring

section CommSemiring
variable [CommSemiring R]

instance nonUnitalCommSemiring [AddCommSemigroup M] : NonUnitalCommSemiring R[M] where
  mul_comm f g := by simp [mul_def, Finsupp.sum, add_comm, mul_comm, f.coeff.support.sum_comm]

lemma single_zero_comm [AddZeroClass M] (r : R) (f : R[M]) : single 0 r * f = f * single 0 r :=
  single_commute .zero_left (.all _) f

section AddCommMonoid
variable [AddCommMonoid M]

instance commSemiring : CommSemiring R[M] where

open Finset in
lemma prod_single (s : Finset ι) (m : ι → M) (r : ι → R) :
    ∏ i ∈ s, single (m i) (r i) = single (∑ i ∈ s, m i) (∏ i ∈ s, r i) :=
  Finset.cons_induction_on s rfl fun i s hi ih ↦ by
    rw [prod_cons, ih, single_mul_single, prod_cons, sum_cons]

end AddCommMonoid
end CommSemiring

section Ring
variable [Ring R]

instance addCommGroup : AddCommGroup R[M] := coeffEquiv.addCommGroup

@[simp] lemma coeff_neg (x : R[M]) : (-x).coeff = -x.coeff := rfl
@[simp] lemma ofCoeff_neg (x : M →₀ R) : ofCoeff (-x) = -ofCoeff x := rfl

@[simp] lemma single_neg (m : M) (r : R) : single m (-r) = -single m r := by simp [single]

instance nonUnitalNonAssocRing [Add M] : NonUnitalNonAssocRing R[M] where
instance nonUnitalRing [AddSemigroup M] : NonUnitalRing R[M] where

instance nonAssocRing [AddZeroClass M] : NonAssocRing R[M] where
  intCast z := single 0 z
  intCast_ofNat n := by simp [natCast_def]
  intCast_negSucc n := by simp [natCast_def, one_def]

lemma intCast_def [AddZeroClass M] (z : ℤ) : (z : R[M]) = single 0 (z : R) := rfl

instance ring [AddMonoid M] : Ring R[M] where

@[deprecated coeff_neg (since := "2025-08-15")]
lemma neg_apply (m : M) (x : R[M]) : (-x).coeff m = -x.coeff m := rfl

end Ring

section CommRing
variable [CommRing R]

instance nonUnitalCommRing [AddCommSemigroup M] : NonUnitalCommRing R[M] where
instance commRing [AddCommMonoid M] : CommRing R[M] where

end CommRing
end AddMonoidAlgebra
